<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Guincho App - Navega√ß√£o</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            height: 100vh;
            position: relative;
            overflow: hidden;
            background: #000;
        }

        /* Navigation Header - Compact overlay */
        .navigation-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 150;
            background: linear-gradient(180deg, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.4) 80%, transparent 100%);
            padding: 12px 16px 8px 16px;
            text-align: center;
            color: white;
        }

        .header-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .back-button {
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }

        .back-button:hover {
            background: rgba(0,0,0,0.6);
            border-color: rgba(255,255,255,0.5);
        }

        .stop-navigation {
            background: rgba(220, 53, 69, 0.8);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }

        .stop-navigation:hover {
            background: rgba(220, 53, 69, 1);
        }

        .navigation-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .navigation-subtitle {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
        }

        .navigation-distance {
            font-size: 0.75rem;
            color: rgba(40,167,69,1);
            margin-top: 2px;
            font-weight: 600;
        }

        /* Map Container - Expanded for 3D rotation and tilt */
        .map-container {
            position: fixed;
            top: -40vh;
            left: -30vw;
            right: -30vw;
            bottom: -30vh;
            z-index: 1;
            width: 160vw;
            height: 170vh;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* CSS-based 3D perspective as fallback - optimal 45 degrees */
        .map-container.css-3d #map {
            transform: perspective(1000px) rotateX(15deg) scale(1.05);
            transform-origin: center bottom;
            transition: transform 0.5s ease;
        }

        .map-container.css-3d {
            overflow: hidden;
        }

        /* Additional safety for any black borders */
        .map-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f0f0f0;
            z-index: -1;
        }

        /* Ensure proper clipping of the expanded map */
        body {
            overflow: hidden;
        }

        /* Loading for map - Adjusted for expanded container */
        .map-loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
            color: white;
        }

        .map-loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top: 3px solid #1E90FF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .map-loading-text {
            color: white;
            font-size: 1rem;
            text-align: center;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Bottom Info Panel - Compact */
        .bottom-info {
            position: fixed;
            bottom: 12px;
            left: 12px;
            right: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
        }

        .route-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .route-stat {
            text-align: center;
            flex: 1;
        }

        .route-stat-label {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 1px;
        }

        .route-stat-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }

        .current-instruction {
            background: rgba(255,255,255,0.1);
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            text-align: center;
            line-height: 1.2;
        }

        /* Navigation Status - Compact */
        .nav-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(40,167,69,0.3);
            border-radius: 16px;
            font-size: 0.7rem;
            margin-top: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Responsive - Mobile first */
        @media (max-width: 480px) {
            .navigation-header {
                padding: 10px 12px 6px 12px;
            }
            
            .bottom-info {
                bottom: 8px;
                left: 8px;
                right: 8px;
                padding: 10px;
            }

            .route-stat-label {
                font-size: 0.6rem;
            }

            .route-stat-value {
                font-size: 0.75rem;
            }

            .current-instruction {
                font-size: 0.75rem;
                padding: 6px 8px;
            }

            .navigation-title {
                font-size: 0.9rem;
            }

            .navigation-subtitle {
                font-size: 0.75rem;
            }

            /* Extra safety for mobile devices */
            .map-container.css-3d #map {
                transform: perspective(1000px) rotateX(15deg) scale(1.1);
            }
        }

        /* Recalculation notification - Compact */
        .recalc-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,193,7,0.9);
            color: #000;
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 200;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .recalc-notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(8px);
        }

        /* Orientation Controls */
        .orientation-controls {
            position: fixed;
            top: 80px;
            right: 12px;
            z-index: 160;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .orientation-btn {
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 22px;
            color: white;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .orientation-btn:hover {
            background: rgba(0,0,0,0.9);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .orientation-btn.active {
            background: rgba(30,144,255,0.8);
            border-color: rgba(30,144,255,1);
            box-shadow: 0 0 12px rgba(30,144,255,0.5);
        }

        /* GPS Precision Indicator */
        .gps-indicator {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            background: #28a745;
            box-shadow: 0 0 6px rgba(40,167,69,0.6);
        }

        .gps-indicator.medium { background: #ffc107; }
        .gps-indicator.low { background: #dc3545; }

        /* Enhanced Triangle with Shadow */
        .navigation-marker-enhanced {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
        }

        /* Mini Compass */
        .mini-compass {
            position: fixed;
            bottom: 120px;
            right: 12px;
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            z-index: 150;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .mini-compass.visible {
            display: flex;
        }

        .compass-needle {
            width: 2px;
            height: 20px;
            background: linear-gradient(to top, #dc3545 0%, #dc3545 50%, #28a745 50%, #28a745 100%);
            transform-origin: center bottom;
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Map Container -->
    <div class="map-container">
        <div class="map-loading" id="mapLoading">
            <div class="map-loading-spinner"></div>
            <div class="map-loading-text">
                Iniciando navega√ß√£o...<br>
                <small>Carregando rota e GPS</small>
            </div>
        </div>
        <div id="map"></div>
    </div>

    <!-- Navigation Header -->
    <div class="navigation-header">
        <div class="header-top">
            <button class="back-button" onclick="goBack()">
                <i class="fas fa-arrow-left"></i>
            </button>
            <button class="stop-navigation" onclick="stopNavigation()">
                <i class="fas fa-stop"></i> Parar
            </button>
        </div>
        <div class="navigation-title">Navegando para destino</div>
        <div class="navigation-subtitle" id="navigationSubtitle">Siga as instru√ß√µes do mapa</div>
        <div class="navigation-distance" id="navigationDistance">Calculando rota...</div>
    </div>

    <!-- Bottom Info Panel -->
    <div class="bottom-info">
        <div class="route-info">
            <div class="route-stat">
                <div class="route-stat-label">Dist√¢ncia</div>
                <div class="route-stat-value" id="totalDistance">-</div>
            </div>
            <div class="route-stat">
                <div class="route-stat-label">Tempo</div>
                <div class="route-stat-value" id="totalTime">-</div>
            </div>
            <div class="route-stat">
                <div class="route-stat-label">Chegada</div>
                <div class="route-stat-value" id="arrivalTime">-</div>
            </div>
        </div>
        
        <div class="current-instruction" id="currentInstruction">
            Inicializando navega√ß√£o...
        </div>
        
        <div class="nav-status">
            <div class="status-dot"></div>
            <span>Navega√ß√£o ativa</span>
        </div>
    </div>

    <!-- Recalculation notification -->
    <div class="recalc-notification" id="recalcNotification">
        <i class="fas fa-route"></i> Rota recalculada
    </div>

    <!-- Orientation Controls -->
    <div class="orientation-controls">
        <button class="orientation-btn active" id="orientationBtn" onclick="toggleOrientationMode()" title="Modo de Orienta√ß√£o">
            <i class="fas fa-compass"></i>
            <div class="gps-indicator" id="gpsIndicator"></div>
        </button>
        <button class="orientation-btn" id="recenterBtn" onclick="recenterMap()" title="Recentralizar">
            <i class="fas fa-crosshairs"></i>
        </button>
    </div>

    <!-- Mini Compass -->
    <div class="mini-compass" id="miniCompass">
        <div class="compass-needle" id="compassNeedle"></div>
    </div>

    <!-- Google Maps API -->
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA5CfnBBfbxBT0xLLpQxFNUCwA3DmVZilE&callback=initNavigation&libraries=geometry,places">
    </script>

    <script>
        // Global variables
        let map;
        let directionsService;
        let directionsRenderer;
        let navigationMarker = null;
        let destinationMarker = null;
        let watchId = null;
        let currentRoute = null;
        let routeSteps = [];
        let currentStepIndex = 0;
        
        // Navigation state
        let isNavigating = false;
        let currentHeading = 0;
        let lastPosition = null;
        let userLocation = null;
        let destinationLocation = null;
        let isRecalculating = false;
        let lastRecalculationTime = 0;
        let routeDeviationThreshold = 50;
        let tiltMonitoringInterval = null;
        
        // Adaptive Orientation System
        let orientationMode = 'auto'; // 'auto', 'compass', 'movement', 'north'
        let navigationState = 'initializing'; // 'initializing', 'navigating', 'arriving', 'lost'
        let userSpeed = 0;
        let lastOrientationUpdate = 0;
        let smoothingLevel = 'medium'; // 'low', 'medium', 'high'
        let rotationSensitivity = 'medium'; // 'low', 'medium', 'high'
        let lastSignificantTurn = 0;
        let stabilityCounter = 0;
        let performanceMode = 'normal'; // 'normal', 'eco'
        
        // Smoothing arrays
        let headingSmoothing = [];
        let positionSmoothing = [];
        let smoothingWindow = 3;
        
        // Locations from URL parameters
        let originAddress = '';
        let destinationAddress = '';

        // ==================== ADAPTIVE ORIENTATION SYSTEM ====================
        
        // Get optimal smoothing settings based on context
        function getAdaptiveSettings(speed, accuracy) {
            if (speed < 0.5) {
                // Stationary or very slow
                return {
                    threshold: 5,
                    smoothingWindow: 5,
                    updateDelay: 200,
                    source: 'compass'
                };
            } else if (speed < 3.0) {
                // Walking/slow movement
                return {
                    threshold: 3,
                    smoothingWindow: 4,
                    updateDelay: 150,
                    source: 'hybrid'
                };
            } else {
                // Driving/fast movement
                return {
                    threshold: 1,
                    smoothingWindow: 3,
                    updateDelay: 100,
                    source: 'gps'
                };
            }
        }

        // Determine navigation state based on context
        function updateNavigationState(speed, distanceToDestination) {
            const previousState = navigationState;
            
            if (distanceToDestination < 50) {
                navigationState = 'arriving';
            } else if (speed < 0.2 && Date.now() - lastOrientationUpdate > 30000) {
                navigationState = 'lost';
            } else if (speed > 0.5) {
                navigationState = 'navigating';
            }
            
            if (previousState !== navigationState) {
                console.log('Navigation state changed:', previousState, '->', navigationState);
                onNavigationStateChange(navigationState);
            }
        }

        // Enhanced navigation state management with transitions
        function onNavigationStateChange(newState) {
            const previousState = navigationState;
            
            // Update UI based on state
            updateNavigationStateUI(newState);
            
            switch(newState) {
                case 'arriving':
                    // Precision mode for final approach
                    smoothingLevel = 'low';
                    rotationSensitivity = 'high';
                    smoothingWindow = 2; // Less smoothing for responsiveness
                    
                    // Enhanced visual feedback
                    showStateNotification('üéØ Chegando ao destino', 'success');
                    
                    // Prepare for parking assistance
                    activateParkingMode();
                    break;
                    
                case 'lost':
                    // Recovery mode - help user reorient
                    smoothingLevel = 'medium';
                    rotationSensitivity = 'low';
                    smoothingWindow = 4; // More smoothing to reduce jitter
                    
                    // Auto-recenter and provide guidance
                    setTimeout(() => recenterMap(), 1000);
                    showStateNotification('üîÑ Reorientando...', 'warning');
                    
                    // Suggest route recalculation if lost for too long
                    setTimeout(() => {
                        if (navigationState === 'lost') {
                            suggestRouteRecalculation();
                        }
                    }, 15000);
                    break;
                    
                case 'navigating':
                    // Standard navigation mode
                    smoothingLevel = 'medium';
                    rotationSensitivity = 'medium';
                    smoothingWindow = 3;
                    
                    if (previousState === 'lost') {
                        showStateNotification('‚úÖ Navega√ß√£o retomada', 'success');
                    }
                    break;
                    
                case 'paused':
                    // User stopped - conserve battery
                    performanceMode = 'eco';
                    smoothingLevel = 'high';
                    break;
                    
                case 'traffic':
                    // Traffic detected - suggest alternatives
                    showStateNotification('üö¶ Tr√¢nsito detectado', 'info');
                    setTimeout(() => suggestAlternativeRoute(), 5000);
                    break;
            }
            
            // Log state transition for debugging
            console.log('Navigation state transition:', {
                from: previousState,
                to: newState,
                timestamp: new Date().toLocaleTimeString(),
                context: {
                    speed: userSpeed?.toFixed(1) + 'm/s',
                    accuracy: userLocation?.accuracy + 'm'
                }
            });
        }
        
        // Update UI elements based on navigation state
        function updateNavigationStateUI(state) {
            const statusElement = document.querySelector('.nav-status span');
            const statusDot = document.querySelector('.status-dot');
            
            switch(state) {
                case 'arriving':
                    statusElement.textContent = 'Chegando ao destino';
                    statusDot.style.background = '#FFD700';
                    statusDot.style.animation = 'pulse 1s infinite';
                    break;
                case 'lost':
                    statusElement.textContent = 'Reorientando posi√ß√£o';
                    statusDot.style.background = '#FF6B6B';
                    statusDot.style.animation = 'pulse 0.5s infinite';
                    break;
                case 'navigating':
                    statusElement.textContent = 'Navega√ß√£o ativa';
                    statusDot.style.background = '#28a745';
                    statusDot.style.animation = 'pulse 2s infinite';
                    break;
                case 'paused':
                    statusElement.textContent = 'Navega√ß√£o pausada';
                    statusDot.style.background = '#6c757d';
                    statusDot.style.animation = 'none';
                    break;
                case 'traffic':
                    statusElement.textContent = 'Tr√¢nsito detectado';
                    statusDot.style.background = '#FFA500';
                    statusDot.style.animation = 'pulse 1.5s infinite';
                    break;
            }
        }
        
        // Show contextual state notifications
        function showStateNotification(message, type = 'info') {
            const notification = document.getElementById('recalcNotification');
            const icon = notification.querySelector('i');
            
            // Update notification appearance based on type
            notification.innerHTML = `<i class="fas ${getNotificationIcon(type)}"></i> ${message}`;
            
            // Style based on type
            switch(type) {
                case 'success':
                    notification.style.background = 'rgba(40,167,69,0.9)';
                    notification.style.color = 'white';
                    break;
                case 'warning':
                    notification.style.background = 'rgba(255,193,7,0.9)';
                    notification.style.color = '#000';
                    break;
                case 'error':
                    notification.style.background = 'rgba(220,53,69,0.9)';
                    notification.style.color = 'white';
                    break;
                default:
                    notification.style.background = 'rgba(23,162,184,0.9)';
                    notification.style.color = 'white';
            }
            
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        function getNotificationIcon(type) {
            switch(type) {
                case 'success': return 'fa-check-circle';
                case 'warning': return 'fa-exclamation-triangle';
                case 'error': return 'fa-times-circle';
                case 'info': return 'fa-info-circle';
                default: return 'fa-info';
            }
        }
        
        // Parking assistance mode
        function activateParkingMode() {
            // Increase marker sensitivity for final positioning
            smoothingWindow = 1; // Minimal smoothing for precision
            
            // Enhanced visual feedback for arrival
            if (navigationMarker) {
                // Increase marker size and change color for arrival
                updateNavigationMarker(userLocation);
            }
        }
        
        // Suggest route recalculation when lost
        function suggestRouteRecalculation() {
            const shouldRecalc = confirm('Parece que voc√™ se desviou da rota. Deseja recalcular?');
            if (shouldRecalc && userLocation) {
                recalculateRoute(userLocation);
            }
        }
        
        // Suggest alternative route during traffic
        function suggestAlternativeRoute() {
            showStateNotification('üí° Calculando rotas alternativas...', 'info');
            // This would integrate with traffic data services
        }

        // Intelligent orientation selection
        function getOptimalHeading(gpsHeading, compassHeading, movementHeading, speed, accuracy) {
            const settings = getAdaptiveSettings(speed, accuracy);
            
            switch(orientationMode) {
                case 'north':
                    return 0; // Always north
                    
                case 'compass':
                    return compassHeading || 0;
                    
                case 'movement':
                    return movementHeading || gpsHeading || compassHeading || 0;
                    
                case 'auto':
                default:
                    // Intelligent selection based on context
                    if (settings.source === 'gps' && gpsHeading !== null) {
                        return gpsHeading;
                    } else if (settings.source === 'compass' && compassHeading !== null) {
                        return compassHeading;
                    } else if (settings.source === 'hybrid') {
                        // Blend GPS and compass
                        if (gpsHeading !== null && compassHeading !== null) {
                            const weight = Math.min(speed / 2.0, 1.0); // Weight towards GPS as speed increases
                            return blendHeadings(gpsHeading, compassHeading, weight);
                        }
                        return gpsHeading || compassHeading || movementHeading || 0;
                    }
                    return movementHeading || 0;
            }
        }

        // Blend two headings with weight
        function blendHeadings(heading1, heading2, weight) {
            // Convert to radians
            const rad1 = heading1 * Math.PI / 180;
            const rad2 = heading2 * Math.PI / 180;
            
            // Blend using circular interpolation
            const x = (1 - weight) * Math.cos(rad1) + weight * Math.cos(rad2);
            const y = (1 - weight) * Math.sin(rad1) + weight * Math.sin(rad2);
            
            // Convert back to degrees
            let result = Math.atan2(y, x) * 180 / Math.PI;
            return (result + 360) % 360;
        }

        // Detect significant turns for instant rotation
        function detectSignificantTurn(newHeading, threshold = 30) {
            const headingDiff = Math.abs(newHeading - currentHeading);
            const normalizedDiff = Math.min(headingDiff, 360 - headingDiff);
            
            if (normalizedDiff > threshold) {
                lastSignificantTurn = Date.now();
                return true;
            }
            return false;
        }

        // Advanced performance optimization with debouncing and batching
        let updateQueue = [];
        let isProcessingUpdates = false;
        let pendingAnimationFrame = null;
        
        function shouldUpdateOrientation(newHeading, speed) {
            const timeSinceLastUpdate = Date.now() - lastOrientationUpdate;
            const headingChange = Math.abs(newHeading - currentHeading);
            
            // Always update on significant turns
            if (detectSignificantTurn(newHeading)) {
                return true;
            }
            
            // Adaptive performance based on device capabilities
            const performanceThreshold = getPerformanceThreshold();
            
            // Reduce updates when driving straight at high speed
            if (speed > 5.0 && headingChange < 2 && timeSinceLastUpdate < performanceThreshold) {
                return false;
            }
            
            // Battery optimization for low-power devices
            if (performanceMode === 'eco' && headingChange < 1 && timeSinceLastUpdate < 300) {
                return false;
            }
            
            // Normal update frequency
            return timeSinceLastUpdate > Math.max(100, performanceThreshold / 2);
        }
        
        // Detect device performance capabilities
        function getPerformanceThreshold() {
            // Check device memory and connection
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            const memory = navigator.deviceMemory || 4; // Default to 4GB
            
            if (memory < 2 || (connection && connection.effectiveType === '2g')) {
                performanceMode = 'eco';
                return 800; // Slower updates for low-end devices
            } else if (memory < 4 || (connection && connection.effectiveType === '3g')) {
                return 500; // Medium updates
            } else {
                return 200; // Fast updates for high-end devices
            }
        }
        
        // Batch updates using requestAnimationFrame
        function scheduleMapUpdate(updateFn) {
            updateQueue.push(updateFn);
            
            if (!pendingAnimationFrame) {
                pendingAnimationFrame = requestAnimationFrame(() => {
                    processBatchedUpdates();
                    pendingAnimationFrame = null;
                });
            }
        }
        
        function processBatchedUpdates() {
            if (isProcessingUpdates || updateQueue.length === 0) return;
            
            isProcessingUpdates = true;
            
            try {
                // Process all queued updates in a single animation frame
                while (updateQueue.length > 0) {
                    const updateFn = updateQueue.shift();
                    updateFn();
                }
            } catch (error) {
                console.error('Error processing batched updates:', error);
            } finally {
                isProcessingUpdates = false;
            }
        }

        // Initialize navigation from URL parameters
        function initNavigation() {
            // Get parameters from URL
            const urlParams = new URLSearchParams(window.location.search);
            
            // Parse origin coordinates
            const originLat = parseFloat(urlParams.get('originLat'));
            const originLng = parseFloat(urlParams.get('originLng'));
            
            // Safe decode addresses with fallback
            try {
                originAddress = decodeURIComponent(urlParams.get('originAddress') || 'Origem');
            } catch (e) {
                originAddress = urlParams.get('originAddress') || 'Origem';
            }
            
            // Parse destination coordinates  
            const destLat = parseFloat(urlParams.get('destLat'));
            const destLng = parseFloat(urlParams.get('destLng'));
            
            try {
                destinationAddress = decodeURIComponent(urlParams.get('destAddress') || 'Destino');
            } catch (e) {
                destinationAddress = urlParams.get('destAddress') || 'Destino';
            }
            
            // Validate parameters
            if (isNaN(originLat) || isNaN(originLng) || isNaN(destLat) || isNaN(destLng)) {
                alert('Par√¢metros de navega√ß√£o inv√°lidos. Retornando...');
                goBack();
                return;
            }
            
            userLocation = { lat: originLat, lng: originLng };
            destinationLocation = { lat: destLat, lng: destLng };
            
            console.log('Navigation initialized:', { userLocation, destinationLocation });
            
            // Update page title with destination
            const shortDestination = formatAddressForDisplay(destinationAddress);
            document.getElementById('navigationSubtitle').textContent = `Para: ${shortDestination}`;
            
            // Initialize map with Vector map type for better 3D support in newer API versions
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 20, // Higher zoom for better 3D effect
                center: userLocation,
                mapTypeId: 'roadmap',
                mapId: 'DEMO_MAP_ID', // Required for advanced features
                tilt: 45, // Revertido para 45 graus - 60 corta o mapa
                heading: currentHeading,
                disableDefaultUI: true,
                gestureHandling: 'greedy',
                minZoom: 16,
                maxZoom: 22,
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: false,
                restriction: {
                    latLngBounds: {
                        north: userLocation.lat + 0.5,
                        south: userLocation.lat - 0.5,
                        east: userLocation.lng + 0.5,
                        west: userLocation.lng - 0.5
                    }
                }
            });
            
            // Apply 3D navigation view with modern approach
            google.maps.event.addListenerOnce(map, 'tilesloaded', function() {
                console.log('Map tiles loaded, applying 3D configuration...');
                
                // Use requestAnimationFrame for smooth 3D application
                function apply3DView() {
                    requestAnimationFrame(() => {
                        // Set high zoom first for better 3D support
                        map.setZoom(20);
                        
                        // Apply tilt gradually
                        let currentTilt = 0;
                        const targetTilt = 45; // Revertido para 45 graus
                        const tiltStep = 5;
                        
                        function increaseTilt() {
                            if (currentTilt < targetTilt) {
                                currentTilt += tiltStep;
                                map.setTilt(Math.min(currentTilt, targetTilt));
                                
                                // Check if tilt was actually applied
                                const actualTilt = map.getTilt();
                                console.log(`Applying tilt: ${currentTilt}, Actual: ${actualTilt}`);
                                
                                if (actualTilt > 0) {
                                    // Success! Continue to full tilt
                                    setTimeout(increaseTilt, 100);
                                } else if (currentTilt < targetTilt) {
                                    // Try alternative approach
                                    tryAlternative3D();
                                    return;
                                }
                            } else {
                                const finalTilt = map.getTilt();
                                console.log('3D navigation configured! Final tilt:', finalTilt);
                                
                                // If tilt still didn't work, use CSS fallback
                                if (finalTilt < 10) { // Revertido threshold
                                    console.log('Google Maps tilt not supported, using CSS 3D fallback');
                                    document.querySelector('.map-container').classList.add('css-3d');
                                }
                                
                                // Set initial heading - o mapa come√ßa com norte para cima
                                // Conforme o usu√°rio gira, o MAPA vai rotacionar para manter a seta sempre apontando para cima
                                map.setHeading(0);
                                console.log('Mapa inicializado com norte para cima. A seta permanece fixa e o mapa rotaciona conforme orienta√ß√£o.');
                                
                                // Start monitoring
                                startTiltMonitoring();
                            }
                        }
                        
                        // Start tilt application
                        increaseTilt();
                    });
                }
                
                // Alternative approach if direct tilt fails
                function tryAlternative3D() {
                    console.log('Trying alternative 3D approach with CSS fallback...');
                    
                    // Skip satellite switching, go directly to CSS fallback
                    console.log('Using CSS 3D fallback for consistent visual experience');
                    document.querySelector('.map-container').classList.add('css-3d');
                    
                    startTiltMonitoring();
                }
                
                // Start the process
                setTimeout(apply3DView, 1000);
            });

            // Initialize directions service
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true,
                preserveViewport: true, // Prevent DirectionsRenderer from changing view
                polylineOptions: {
                    strokeColor: '#1E90FF',
                    strokeWeight: 10,
                    strokeOpacity: 1.0,
                    zIndex: 200
                }
            });
            
            directionsRenderer.setMap(map);
            
            // Prevent DirectionsRenderer from resetting 3D view
            google.maps.event.addListener(directionsRenderer, 'directions_changed', function() {
                console.log('Directions changed, maintaining 3D view...');
                setTimeout(() => {
                    force3DViewMaintenance();
                }, 200);
            });
            
            // Hide loading and start navigation
            document.getElementById('mapLoading').style.display = 'none';
            
            // Start navigation immediately
            startNavigation();
        }

        // Start navigation with route calculation
        function startNavigation() {
            addDebugLog('üöÄ Iniciando navega√ß√£o...');
            
            const request = {
                origin: userLocation,
                destination: destinationLocation,
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
                avoidHighways: false,
                avoidTolls: false
            };
            
            addDebugLog(`üó∫Ô∏è Calculando rota de ${userLocation.lat.toFixed(4)},${userLocation.lng.toFixed(4)} para ${destinationLocation.lat.toFixed(4)},${destinationLocation.lng.toFixed(4)}`);

            directionsService.route(request, function(result, status) {
                addDebugLog(`üó∫Ô∏è Status da rota: ${status}`);
                
                if (status === 'OK') {
                    currentRoute = result;
                    routeSteps = result.routes[0].legs[0].steps;
                    currentStepIndex = 0;
                    
                    addDebugLog(`‚úÖ Rota calculada com ${routeSteps.length} etapas`);
                    
                    // Display route
                    directionsRenderer.setDirections(result);
                    addDebugLog('üó∫Ô∏è Rota exibida no mapa');
                    
                    // Create markers
                    createNavigationMarker();
                    createDestinationMarker();
                    addDebugLog('üìç Marcadores criados');
                    
                    // Update UI
                    updateNavigationInfo(result);
                    addDebugLog('üìä Interface atualizada');
                    
                    // Start GPS tracking
                    startGPSTracking();
                    addDebugLog('üì∂ GPS iniciado');
                    
                    // Initialize compass heading if available
                    initializeCompass();
                    addDebugLog('üß≠ B√∫ssola inicializada');
                    
                    // For√ßar navega√ß√£o ativa
                    isNavigating = true;
                    addDebugLog(`‚úÖ isNavigating definido como: ${isNavigating}`);
                    
                    console.log('Navigation started with', routeSteps.length, 'steps');
                    addDebugLog(`üèÅ NAVEGA√á√ÉO INICIADA! ${routeSteps.length} etapas`);
                    
                } else {
                    addDebugLog(`‚ùå Erro ao calcular rota: ${status}`);
                    alert('N√£o foi poss√≠vel calcular a rota: ' + status);
                    goBack();
                }
            });
        }

        // Create navigation arrow marker (seta fixa sempre para cima)
        function createNavigationMarker() {
            if (navigationMarker) {
                navigationMarker.setMap(null);
            }
            
            navigationMarker = new google.maps.Marker({
                position: userLocation,
                map: map,
                icon: {
                    // Seta azul sempre apontando para o topo da tela
                    path: 'M0,-20 L-10,10 L0,5 L10,10 Z',
                    fillColor: '#1E90FF',
                    fillOpacity: 1.0,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2,
                    scale: 1.56, // 30% maior que 1.2
                    anchor: new google.maps.Point(0, 0),
                    rotation: 0 // Sempre 0 - seta fixa para o topo
                },
                zIndex: 1000,
                optimized: false
            });
        }

        // Create destination marker
        function createDestinationMarker() {
            if (destinationMarker) {
                destinationMarker.setMap(null);
            }
            
            destinationMarker = new google.maps.Marker({
                position: destinationLocation,
                map: map,
                icon: {
                    path: 'M12,2C8.13,2 5,5.13 5,9C5,14.25 12,22 12,22C12,22 19,14.25 19,9C19,5.13 15.87,2 12,2Z',
                    fillColor: '#DC143C',
                    fillOpacity: 1,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2,
                    scale: 1.2,
                    anchor: new google.maps.Point(12, 22)
                },
                title: 'Destino',
                zIndex: 999
            });
        }

        // Initialize compass and device orientation
        function initializeCompass() {
            console.log('üß≠ Inicializando b√∫ssola e orienta√ß√£o do dispositivo...');
            
            // Adicionar indicador visual de debug na tela
            createDebugIndicator();
            
            // Verificar se o dispositivo suporta orienta√ß√£o
            if (!window.DeviceOrientationEvent) {
                console.warn('‚ùå DeviceOrientationEvent n√£o suportado');
                updateDebugIndicator('‚ùå Orienta√ß√£o n√£o suportada');
                return;
            }
            
            // Solicitar permiss√£o para iOS 13+
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                console.log('üì± Detectado iOS 13+ - Solicitando permiss√£o...');
                updateDebugIndicator('üì± Toque para ativar b√∫ssola');
                
                // Criar bot√£o para solicitar permiss√£o (requerido pelo iOS)
                const permissionBtn = document.createElement('button');
                permissionBtn.textContent = 'Ativar B√∫ssola e Rota√ß√£o';
                permissionBtn.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 300;
                    background: #007bff;
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 10px;
                    font-size: 1.1rem;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;
                
                permissionBtn.onclick = () => {
                    console.log('üîÑ Solicitando permiss√£o de orienta√ß√£o...');
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            permissionBtn.remove();
                            if (response === 'granted') {
                                console.log('‚úÖ Permiss√£o de orienta√ß√£o concedida!');
                                updateDebugIndicator('‚úÖ B√∫ssola ativada');
                                startCompassTracking();
                            } else {
                                console.warn('‚ùå Permiss√£o de orienta√ß√£o negada');
                                updateDebugIndicator('‚ùå Permiss√£o negada');
                                alert('Para rota√ß√£o autom√°tica do mapa, permita o acesso √† b√∫ssola.');
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Erro ao solicitar permiss√£o:', error);
                            updateDebugIndicator('‚ùå Erro: ' + error.message);
                            permissionBtn.remove();
                        });
                };
                
                document.body.appendChild(permissionBtn);
            } else {
                // Dispositivos que n√£o precisam de permiss√£o
                console.log('ü§ñ Android/outros - Iniciando b√∫ssola diretamente');
                updateDebugIndicator('ü§ñ Iniciando b√∫ssola...');
                startCompassTracking();
            }
        }

        // Advanced debug panel for iPhone testing
        let debugLogs = [];
        let debugPanel = null;
        
        function createDebugIndicator() {
            debugPanel = document.createElement('div');
            debugPanel.id = 'debugPanel';
            debugPanel.style.cssText = `
                position: fixed;
                top: 100px;
                left: 5px;
                right: 5px;
                background: rgba(0,0,0,0.95);
                color: #00ff00;
                padding: 10px;
                font-size: 11px;
                border-radius: 8px;
                z-index: 300;
                font-family: 'Courier New', monospace;
                max-height: 300px;
                overflow-y: auto;
                border: 2px solid #00ff00;
            `;
            
            debugPanel.innerHTML = `
                <div style="text-align: center; color: #ffff00; font-weight: bold; margin-bottom: 8px;">
                    üîß DEBUG PANEL - iPhone
                </div>
                <div id="debugStatus">Inicializando...</div>
                <div id="debugData" style="margin-top: 8px; font-size: 10px;"></div>
                <div style="text-align: center; margin-top: 8px;">
                    <button onclick="copyDebugInfo()" style="background: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 4px; font-size: 10px;">üìã Copiar Debug</button>
                    <button onclick="toggleDebugPanel()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; font-size: 10px; margin-left: 5px;">‚ùå Fechar</button>
                </div>
                <div id="debugLogs" style="margin-top: 8px; max-height: 150px; overflow-y: auto; font-size: 9px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px;"></div>
            `;
            
            document.body.appendChild(debugPanel);
            addDebugLog('üöÄ Debug panel criado');
        }
        
        function addDebugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            debugLogs.push(logEntry);
            
            // Manter apenas √∫ltimos 20 logs
            if (debugLogs.length > 20) {
                debugLogs.shift();
            }
            
            // Atualizar display
            const logsDiv = document.getElementById('debugLogs');
            if (logsDiv) {
                logsDiv.innerHTML = debugLogs.map(log => `<div>${log}</div>`).join('');
                logsDiv.scrollTop = logsDiv.scrollHeight;
            }
            
            console.log('DEBUG:', message);
        }
        
        function updateDebugStatus(text) {
            const statusDiv = document.getElementById('debugStatus');
            if (statusDiv) {
                statusDiv.innerHTML = text;
            }
            addDebugLog(text);
        }
        
        function updateDebugData(data) {
            const dataDiv = document.getElementById('debugData');
            if (dataDiv) {
                dataDiv.innerHTML = data;
            }
        }
        
        function copyDebugInfo() {
            const debugInfo = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                currentHeading: currentHeading,
                orientationMode: orientationMode,
                isNavigating: isNavigating,
                mapHeading: map ? map.getHeading() : 'N/A',
                mapTilt: map ? map.getTilt() : 'N/A',
                logs: debugLogs,
                deviceInfo: {
                    hasDeviceOrientation: !!window.DeviceOrientationEvent,
                    hasRequestPermission: typeof DeviceOrientationEvent.requestPermission === 'function',
                    hasAbsoluteOrientation: 'ondeviceorientationabsolute' in window
                }
            };
            
            const debugText = JSON.stringify(debugInfo, null, 2);
            
            // Tentar copiar para clipboard
            if (navigator.clipboard) {
                navigator.clipboard.writeText(debugText).then(() => {
                    alert('‚úÖ Debug info copiado para clipboard!');
                }).catch(() => {
                    showTextToCopy(debugText);
                });
            } else {
                showTextToCopy(debugText);
            }
        }
        
        function showTextToCopy(text) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                z-index: 400;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 10px; max-width: 90%; max-height: 80%; overflow: auto;">
                    <h3>üìã Copie o texto abaixo:</h3>
                    <textarea readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 10px;">${text}</textarea>
                    <button onclick="this.parentElement.parentElement.remove()" style="margin-top: 10px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px;">Fechar</button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function toggleDebugPanel() {
            if (debugPanel) {
                debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // Start compass tracking
        function startCompassTracking() {
            if (!window.DeviceOrientationEvent) {
                console.error('‚ùå DeviceOrientationEvent n√£o dispon√≠vel');
                updateDebugIndicator('‚ùå Orienta√ß√£o n√£o dispon√≠vel');
                return;
            }
            
            console.log('üîÑ Iniciando rastreamento de b√∫ssola...');
            updateDebugIndicator('üîÑ Conectando eventos...');
            
            // Remover listeners existentes
            window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
            window.removeEventListener('deviceorientationabsolute', handleDeviceOrientation, true);
            
            // Teste simples primeiro
            let testReceived = false;
            
            function testOrientation(event) {
                testReceived = true;
                console.log('üì° Evento de orienta√ß√£o recebido!', {
                    alpha: event.alpha,
                    beta: event.beta, 
                    gamma: event.gamma,
                    absolute: event.absolute,
                    webkitCompassHeading: event.webkitCompassHeading
                });
                updateDebugIndicator(`üì° Œ±:${event.alpha?.toFixed(1)} Œ≤:${event.beta?.toFixed(1)} Œ≥:${event.gamma?.toFixed(1)}`);
            }
            
            // Tentar usar deviceorientationabsolute primeiro (mais preciso)
            if ('ondeviceorientationabsolute' in window) {
                window.addEventListener('deviceorientationabsolute', testOrientation, true);
                window.addEventListener('deviceorientationabsolute', handleDeviceOrientation, true);
                console.log('üéØ Usando deviceorientationabsolute (mais preciso)');
                updateDebugIndicator('üéØ Usando orienta√ß√£o absoluta');
            } else {
                window.addEventListener('deviceorientation', testOrientation, true);
                window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                console.log('üì± Usando deviceorientation padr√£o');
                updateDebugIndicator('üì± Usando orienta√ß√£o padr√£o');
            }
            
            // Testar se est√° funcionando
            setTimeout(() => {
                if (!testReceived) {
                    console.warn('‚ö†Ô∏è Nenhum evento de orienta√ß√£o recebido em 3s!');
                    updateDebugIndicator('‚ö†Ô∏è Sem eventos - Tentando GPS');
                    orientationMode = 'movement';
                    updateOrientationButton();
                } else {
                    console.log('‚úÖ Eventos de orienta√ß√£o funcionando!');
                    updateDebugIndicator('‚úÖ Orienta√ß√£o ativa');
                }
            }, 3000);
        }

        // Handle device orientation changes
        function handleDeviceOrientation(event) {
            let compassHeading = null;
            let debugInfo = '';
            
            // REMOVER DEPEND√äNCIA DE isNavigating - sempre processar eventos
            addDebugLog(`üì° Evento de orienta√ß√£o recebido (isNavigating: ${isNavigating})`);
            
            // Coletar todos os dados do evento
            const eventData = {
                alpha: event.alpha,
                beta: event.beta,
                gamma: event.gamma,
                absolute: event.absolute,
                webkitCompassHeading: event.webkitCompassHeading
            };
            
            // Melhorada compatibilidade entre dispositivos
            if (typeof event.webkitCompassHeading !== 'undefined' && event.webkitCompassHeading !== null) {
                // iOS Safari - valor j√° corrigido para norte magn√©tico
                compassHeading = event.webkitCompassHeading;
                debugInfo = `üçé iOS: ${compassHeading.toFixed(1)}¬∞`;
                addDebugLog(`iOS webkitCompassHeading: ${compassHeading.toFixed(1)}¬∞`);
            } else if (typeof event.alpha !== 'undefined' && event.alpha !== null) {
                // Android e outros navegadores
                if (event.absolute === true || typeof event.absolute === 'undefined') {
                    // Alpha √© relativo ao norte magn√©tico
                    compassHeading = 360 - event.alpha;
                } else {
                    // Alpha √© relativo √† orienta√ß√£o inicial do dispositivo
                    compassHeading = event.alpha;
                }
                debugInfo = `ü§ñ Œ±=${event.alpha.toFixed(1)}¬∞ ‚Üí ${compassHeading.toFixed(1)}¬∞`;
                addDebugLog(`Alpha: ${event.alpha.toFixed(1)}¬∞ (abs: ${event.absolute}) ‚Üí ${compassHeading.toFixed(1)}¬∞`);
            }
            
            // Atualizar dados na tela
            updateDebugData(`
                <strong>Dados do Sensor:</strong><br>
                Œ±: ${eventData.alpha?.toFixed(1) || 'null'}¬∞ | 
                Œ≤: ${eventData.beta?.toFixed(1) || 'null'}¬∞ | 
                Œ≥: ${eventData.gamma?.toFixed(1) || 'null'}¬∞<br>
                Absoluto: ${eventData.absolute}<br>
                WebKit: ${eventData.webkitCompassHeading?.toFixed(1) || 'null'}¬∞<br>
                <strong>Heading Calculado:</strong> ${compassHeading?.toFixed(1) || 'null'}¬∞<br>
                <strong>isNavigating:</strong> ${isNavigating}<br>
                <strong>Mapa dispon√≠vel:</strong> ${map ? 'Sim' : 'N√£o'}
            `);
            
            if (compassHeading !== null && !isNaN(compassHeading)) {
                // Normalizar para faixa 0-360
                compassHeading = ((compassHeading % 360) + 360) % 360;
                
                // TESTE DIRETO - aplicar rota√ß√£o SEMPRE (sem depend√™ncia de isNavigating)
                if (map) {
                    try {
                        // For√ßar navega√ß√£o se n√£o estiver ativa
                        if (!isNavigating) {
                            addDebugLog(`‚ö†Ô∏è isNavigating era false, for√ßando para true`);
                            isNavigating = true;
                        }
                        
                        // Verificar se o mapa est√° realmente dispon√≠vel
                        const currentMapHeading = map.getHeading();
                        const currentMapTilt = map.getTilt();
                        
                        addDebugLog(`Estado do mapa - Heading: ${currentMapHeading?.toFixed(1)}¬∞, Tilt: ${currentMapTilt?.toFixed(1)}¬∞`);
                        
                        // Calcular diferen√ßa
                        const targetMapHeading = (360 - compassHeading) % 360; // Inverter para rota√ß√£o correta
                        let headingDiff = targetMapHeading - (currentMapHeading || 0);
                        
                        // Normalizar diferen√ßa
                        if (headingDiff > 180) headingDiff -= 360;
                        if (headingDiff < -180) headingDiff += 360;
                        
                        // Aplicar rota√ß√£o se diferen√ßa > 3¬∞ (mais sens√≠vel)
                        if (Math.abs(headingDiff) > 3) {
                            addDebugLog(`üîÑ TENTANDO ROTA√á√ÉO: ${compassHeading.toFixed(1)}¬∞ ‚Üí ${targetMapHeading.toFixed(1)}¬∞`);
                            
                            // Tentar aplicar rota√ß√£o
                            map.setHeading(targetMapHeading);
                            
                            // Verificar se funcionou
                            setTimeout(() => {
                                const newHeading = map.getHeading();
                                addDebugLog(`‚úÖ Resultado: ${newHeading?.toFixed(1)}¬∞ (esperado: ${targetMapHeading.toFixed(1)}¬∞)`);
                                
                                if (Math.abs((newHeading || 0) - targetMapHeading) > 5) {
                                    addDebugLog(`‚ùå ROTA√á√ÉO FALHOU! Diferen√ßa: ${Math.abs((newHeading || 0) - targetMapHeading).toFixed(1)}¬∞`);
                                    
                                    // Tentar diagn√≥stico
                                    addDebugLog(`üîç Diagn√≥stico:`);
                                    addDebugLog(`- MapTypeId: ${map.getMapTypeId()}`);
                                    addDebugLog(`- Zoom: ${map.getZoom()}`);
                                    addDebugLog(`- Tilt: ${map.getTilt()}`);
                                    addDebugLog(`- Centro: ${map.getCenter()}`);
                                } else {
                                    addDebugLog(`‚úÖ ROTA√á√ÉO BEM-SUCEDIDA!`);
                                }
                            }, 100);
                        }
                        
                        // Atualizar status
                        updateDebugStatus(`${debugInfo} | Mapa: ${(currentMapHeading || 0).toFixed(1)}¬∞ | Diff: ${headingDiff.toFixed(1)}¬∞`);
                        
                        // Atualizar heading global
                        currentHeading = compassHeading;
                        
                    } catch (error) {
                        addDebugLog(`‚ùå ERRO no mapa: ${error.message}`);
                        addDebugLog(`‚ùå Stack: ${error.stack}`);
                        updateDebugStatus(`‚ùå Erro: ${error.message}`);
                    }
                } else {
                    addDebugLog(`‚ùå Mapa n√£o dispon√≠vel! Tentando aguardar...`);
                    updateDebugStatus(`‚ùå Mapa null - aguardando`);
                    
                    // Tentar aguardar o mapa ficar dispon√≠vel
                    setTimeout(() => {
                        if (map) {
                            addDebugLog(`‚úÖ Mapa agora dispon√≠vel, reaplicando orienta√ß√£o`);
                            handleDeviceOrientation(event);
                        }
                    }, 1000);
                }
            } else {
                addDebugLog(`‚ùå compassHeading inv√°lido: ${compassHeading}`);
                updateDebugStatus(`‚ùå Heading inv√°lido`);
            }
        }

        // Start GPS tracking
        function startGPSTracking() {
            if (!navigator.geolocation) {
                console.error('Geolocation not supported');
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 3000,
                maximumAge: 1000
            };

            watchId = navigator.geolocation.watchPosition(
                updateNavigationPosition,
                handleGPSError,
                options
            );
        }

        // Update position during navigation with adaptive system
        function updateNavigationPosition(position) {
            if (!isNavigating) return;

            const rawPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 50,
                heading: position.coords.heading,
                speed: position.coords.speed || 0
            };

            // Update global speed for adaptive settings
            userSpeed = rawPosition.speed;

            // Apply smoothing
            const smoothedPosition = applySmoothingToPosition(rawPosition);
            
            // Check for route deviation
            checkRouteDeviation(smoothedPosition);

            // Calculate distance to destination for state management
            const distanceToDestination = calculateDistance(smoothedPosition, destinationLocation);
            
            // Update navigation state
            updateNavigationState(userSpeed, distanceToDestination);

            // Calculate all possible headings
            let gpsHeading = rawPosition.heading;
            let compassHeading = null; // Will be set by device orientation
            let movementHeading = null;

            if (lastPosition) {
                const distance = calculateDistance(lastPosition, smoothedPosition);
                if (distance > 1.0) {
                    movementHeading = calculateHeading(lastPosition, smoothedPosition);
                }
            }

            // Get optimal heading using intelligent system
            const optimalHeading = getOptimalHeading(gpsHeading, compassHeading, movementHeading, userSpeed, rawPosition.accuracy);
            
            // Check if we should update orientation
            if (shouldUpdateOrientation(optimalHeading, userSpeed)) {
                // Apply adaptive smoothing
                const settings = getAdaptiveSettings(userSpeed, rawPosition.accuracy);
                smoothingWindow = settings.smoothingWindow;
                
                const smoothedHeading = applySmoothingToHeading(optimalHeading);
                
                // Update with threshold based on speed and context
                if (Math.abs(smoothedHeading - currentHeading) > settings.threshold || detectSignificantTurn(smoothedHeading)) {
                    currentHeading = smoothedHeading;
                    lastOrientationUpdate = Date.now();
                    
                    console.log('Adaptive heading update:', {
                        heading: currentHeading.toFixed(1) + '¬∞',
                        source: settings.source,
                        speed: userSpeed?.toFixed(1) + 'm/s',
                        threshold: settings.threshold + '¬∞',
                        state: navigationState
                    });
                }
            }

            userLocation = smoothedPosition;
            lastPosition = smoothedPosition;

            // Update visual elements
            updateNavigationMarker(smoothedPosition);
            updateMapFollowing(smoothedPosition);
            updateGPSIndicator(rawPosition.accuracy);
            updateMiniCompass(currentHeading);

            // Update distance display
            updateDistanceDisplay(distanceToDestination);

            // Check arrival
            if (distanceToDestination < 30) {
                arrivedAtDestination();
            }
        }

        // Update navigation info in UI
        function updateNavigationInfo(result) {
            const route = result.routes[0];
            const leg = route.legs[0];
            
            document.getElementById('totalDistance').textContent = leg.distance.text;
            document.getElementById('totalTime').textContent = leg.duration.text;
            
            // Calculate arrival time
            const now = new Date();
            const arrivalTime = new Date(now.getTime() + leg.duration.value * 1000);
            document.getElementById('arrivalTime').textContent = arrivalTime.toLocaleTimeString('pt-BR', {
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // Format destination address for better display
            const shortDestinationAddress = formatAddressForDisplay(destinationAddress);
            document.getElementById('currentInstruction').textContent = 
                `Siga para ${shortDestinationAddress}`;
        }

        // Format address for better display (shorter version)
        function formatAddressForDisplay(fullAddress) {
            if (!fullAddress || fullAddress === 'Origem' || fullAddress === 'Destino') {
                return fullAddress;
            }
            
            // Split address into parts
            const parts = fullAddress.split(',');
            
            if (parts.length >= 2) {
                // Take first two parts (street and number, neighborhood)
                return parts.slice(0, 2).join(',').trim();
            }
            
            // If address is too long, truncate it
            if (fullAddress.length > 40) {
                return fullAddress.substring(0, 37) + '...';
            }
            
            return fullAddress;
        }

        // Update distance display
        function updateDistanceDisplay(distance) {
            const distanceElement = document.getElementById('navigationDistance');
            if (distance < 1000) {
                distanceElement.textContent = `${Math.round(distance)}m restantes`;
            } else {
                distanceElement.textContent = `${(distance / 1000).toFixed(1)}km restantes`;
            }
        }

        // Navigation utility functions (smoothing, calculations, etc.)
        function applySmoothingToPosition(newPosition) {
            positionSmoothing.push(newPosition);
            if (positionSmoothing.length > smoothingWindow) {
                positionSmoothing.shift();
            }

            let totalWeight = 0, weightedLat = 0, weightedLng = 0;
            for (let i = 0; i < positionSmoothing.length; i++) {
                const weight = (i + 1);
                totalWeight += weight;
                weightedLat += positionSmoothing[i].lat * weight;
                weightedLng += positionSmoothing[i].lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: newPosition.accuracy
            };
        }

        function applySmoothingToHeading(newHeading) {
            // Add to smoothing array
            headingSmoothing.push(newHeading);
            if (headingSmoothing.length > smoothingWindow) {
                headingSmoothing.shift();
            }

            // Use circular mean for heading angles
            let x = 0, y = 0;
            for (let i = 0; i < headingSmoothing.length; i++) {
                const weight = (i + 1) / headingSmoothing.length; // Weighted towards more recent values
                const heading = headingSmoothing[i];
                x += Math.cos(heading * Math.PI / 180) * weight;
                y += Math.sin(heading * Math.PI / 180) * weight;
            }

            let smoothedHeading = Math.atan2(y, x) * 180 / Math.PI;
            
            // Normalize to 0-360 range
            if (smoothedHeading < 0) {
                smoothedHeading += 360;
            }
            
            return smoothedHeading;
        }

        function updateNavigationMarker(position) {
            if (!navigationMarker) return;
            navigationMarker.setPosition(position);
            
            // Enhanced triangle with GPS accuracy indication
            let fillColor = '#1E90FF'; // Default blue
            let strokeColor = '#FFFFFF';
            let scale = 1.2;
            
            // Adjust color based on GPS accuracy
            if (userLocation && userLocation.accuracy) {
                if (userLocation.accuracy < 10) {
                    fillColor = '#00FF41'; // High accuracy - green
                } else if (userLocation.accuracy < 25) {
                    fillColor = '#FFD700'; // Medium accuracy - yellow
                } else {
                    fillColor = '#FF6B6B'; // Low accuracy - red
                }
            }
            
            // Adjust size based on speed and navigation state (30% maior)
            switch(navigationState) {
                case 'arriving':
                    scale = 1.82; // 1.4 * 1.3 = Larger when arriving
                    break;
                case 'navigating':
                    scale = userSpeed > 10 ? 1.69 : 1.56; // 1.3 * 1.3 e 1.2 * 1.3
                    break;
                case 'lost':
                    scale = 1.43; // 1.1 * 1.3 = Smaller when lost
                    fillColor = '#FF4444'; // Red when lost
                    break;
                default:
                    scale = 1.56; // 1.2 * 1.3 = 30% maior
            }
            
            navigationMarker.setIcon({
                // Seta sempre apontando para o topo da tela (sem rota√ß√£o)
                path: 'M0,-20 L-10,10 L0,5 L10,10 Z',
                fillColor: fillColor,
                fillOpacity: 0.9,
                strokeColor: strokeColor,
                strokeWeight: 2.5,
                scale: scale,
                anchor: new google.maps.Point(0, 0),
                rotation: 0 // Seta fixa sempre apontando para norte/topo
            });
        }

        function updateMapFollowing(position) {
            if (!map || !position) return;
            
            // Centralizar mapa na posi√ß√£o do usu√°rio
            map.panTo(position);
            
            // Manter 3D tilt
            const currentTilt = map.getTilt();
            if (currentTilt < 35) {
                map.setTilt(45);
            }
            
            // A rota√ß√£o agora √© feita diretamente no handleDeviceOrientation
            // para ser mais responsiva e simples
        }
        
        // Intelligent zoom calculation
        function getAdaptiveZoom() {
            let baseZoom = 20;
            
            switch(navigationState) {
                case 'arriving':
                    return 21; // High detail for parking/arrival
                case 'lost':
                    return 18; // Wider view to help reorient
                case 'navigating':
                    // Speed-based zoom adjustment
                    if (userSpeed > 20) return 18; // Highway speed - wider view
                    if (userSpeed > 10) return 19; // City driving
                    return 20; // Slow/urban navigation
                default:
                    return baseZoom;
            }
        }
        
        // Helper function to normalize heading values
        function normalizeHeading(heading) {
            while (heading < 0) heading += 360;
            while (heading >= 360) heading -= 360;
            return heading;
        }

        function calculateDistance(pos1, pos2) {
            const R = 6371e3;
            const œÜ1 = pos1.lat * Math.PI/180;
            const œÜ2 = pos2.lat * Math.PI/180;
            const ŒîœÜ = (pos2.lat-pos1.lat) * Math.PI/180;
            const ŒîŒª = (pos2.lng-pos1.lng) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        function calculateHeading(from, to) {
            const fromLat = from.lat * Math.PI / 180;
            const fromLng = from.lng * Math.PI / 180;
            const toLat = to.lat * Math.PI / 180;
            const toLng = to.lng * Math.PI / 180;

            const dLng = toLng - fromLng;
            const y = Math.sin(dLng) * Math.cos(toLat);
            const x = Math.cos(fromLat) * Math.sin(toLat) - Math.sin(fromLat) * Math.cos(toLat) * Math.cos(dLng);

            let heading = Math.atan2(y, x) * 180 / Math.PI;
            heading = (heading + 360) % 360;
            return heading;
        }

        // Route deviation and recalculation
        function checkRouteDeviation(currentPosition) {
            if (!currentRoute || isRecalculating) return;
            
            const now = Date.now();
            if (now - lastRecalculationTime < 10000) return;

            const distanceToRoute = calculateDistanceToRoute(currentPosition, currentRoute);
            
            if (distanceToRoute > routeDeviationThreshold) {
                recalculateRoute(currentPosition);
            }
        }

        function calculateDistanceToRoute(position, route) {
            if (!route || !route.routes[0]) return 0;
            
            const path = route.routes[0].overview_path;
            let minDistance = Infinity;
            
            for (let i = 0; i < path.length; i++) {
                const pathPoint = {
                    lat: path[i].lat(),
                    lng: path[i].lng()
                };
                const distance = calculateDistance(position, pathPoint);
                minDistance = Math.min(minDistance, distance);
            }
            
            return minDistance;
        }

        function recalculateRoute(fromPosition) {
            if (isRecalculating) return;
            
            isRecalculating = true;
            lastRecalculationTime = Date.now();
            
            const request = {
                origin: fromPosition,
                destination: destinationLocation,
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC
            };

            directionsService.route(request, function(result, status) {
                isRecalculating = false;
                
                if (status === 'OK') {
                    currentRoute = result;
                    routeSteps = result.routes[0].legs[0].steps;
                    directionsRenderer.setDirections(result);
                    updateNavigationInfo(result);
                    showRecalculationNotification();
                }
            });
        }

        function showRecalculationNotification() {
            const notification = document.getElementById('recalcNotification');
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function handleGPSError(error) {
            console.error('GPS Error:', error);
        }

        function arrivedAtDestination() {
            alert('Chegou ao destino!');
            stopNavigation();
        }

        // Navigation controls
        function stopNavigation() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            isNavigating = false;
            goBack();
        }

        // Start gentle tilt monitoring
        function startTiltMonitoring() {
            console.log('Starting gentle tilt monitoring...');
            
            // Clear any existing interval
            if (tiltMonitoringInterval) {
                clearInterval(tiltMonitoringInterval);
            }
            
            // Monitor tilt every 5 seconds during navigation (less aggressive)
            tiltMonitoringInterval = setInterval(() => {
                if (isNavigating && map) {
                    const currentTilt = map.getTilt();
                    if (currentTilt < 30) { // Revertido para 45 graus
                        console.log(`Gentle tilt correction needed (${currentTilt})`);
                        map.setTilt(45); // Revertido para 45 graus
                        
                        // Verify it worked
                        setTimeout(() => {
                            console.log('Tilt after correction:', map.getTilt());
                        }, 500);
                    }
                }
            }, 5000);
        }

        // Force 3D view maintenance function (CSS-based)
        function force3DViewMaintenance() {
            if (!map) return;
            
            console.log('Maintaining 3D view with CSS fallback...');
            
            // Use CSS 3D instead of satellite switching
            if (!document.querySelector('.map-container').classList.contains('css-3d')) {
                document.querySelector('.map-container').classList.add('css-3d');
                console.log('CSS 3D fallback activated for maintenance');
            }
        }

        // ==================== INTERFACE CONTROLS ====================
        
        // Toggle orientation mode
        function toggleOrientationMode() {
            const modes = ['auto', 'compass', 'movement', 'north'];
            const currentIndex = modes.indexOf(orientationMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            orientationMode = modes[nextIndex];
            
            updateOrientationButton();
            console.log('Orientation mode changed to:', orientationMode);
            
            // Update map immediately
            if (userLocation) {
                updateMapFollowing(userLocation);
            }
        }

        // Update orientation button appearance
        function updateOrientationButton() {
            const btn = document.getElementById('orientationBtn');
            const icon = btn.querySelector('i');
            
            // Remove all classes
            icon.className = 'fas';
            
            switch(orientationMode) {
                case 'auto':
                    icon.classList.add('fa-compass');
                    btn.title = 'Modo Autom√°tico';
                    btn.classList.add('active');
                    break;
                case 'compass':
                    icon.classList.add('fa-location-arrow');
                    btn.title = 'Seguir B√∫ssola';
                    btn.classList.add('active');
                    break;
                case 'movement':
                    icon.classList.add('fa-route');
                    btn.title = 'Seguir Movimento';
                    btn.classList.add('active');
                    break;
                case 'north':
                    icon.classList.add('fa-arrow-up');
                    btn.title = 'Norte Fixo';
                    btn.classList.remove('active');
                    break;
            }
        }

        // Recenter map on user location
        function recenterMap() {
            if (userLocation && map) {
                map.panTo(userLocation);
                map.setZoom(20);
                
                // Add visual feedback
                const btn = document.getElementById('recenterBtn');
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                }, 150);
                
                console.log('Map recentered on user location');
            }
        }

        // Update GPS accuracy indicator
        function updateGPSIndicator(accuracy) {
            const indicator = document.getElementById('gpsIndicator');
            
            indicator.className = 'gps-indicator';
            
            if (accuracy < 10) {
                indicator.classList.add('high');
            } else if (accuracy < 25) {
                indicator.classList.add('medium');
            } else {
                indicator.classList.add('low');
            }
        }

        // Update mini compass
        function updateMiniCompass(heading) {
            const compass = document.getElementById('miniCompass');
            const needle = document.getElementById('compassNeedle');
            
            if (orientationMode === 'compass' || orientationMode === 'auto') {
                compass.classList.add('visible');
                needle.style.transform = `rotate(${heading}deg)`;
            } else {
                compass.classList.remove('visible');
            }
        }

        function goBack() {
            // Stop tilt monitoring
            if (tiltMonitoringInterval) {
                clearInterval(tiltMonitoringInterval);
                tiltMonitoringInterval = null;
            }
            
            window.location.href = 'service-details.html';
        }

        // Fun√ß√µes globais para facilitar debug
        window.showDebug = function() {
            if (debugPanel) {
                debugPanel.style.display = 'block';
            }
        };
        
        window.hideDebug = function() {
            if (debugPanel) {
                debugPanel.style.display = 'none';
            }
        };
        
        window.testRotation = function(degrees) {
            if (map) {
                addDebugLog(`üß™ TESTE MANUAL: Rotacionando para ${degrees}¬∞`);
                map.setHeading(degrees);
                setTimeout(() => {
                    const newHeading = map.getHeading();
                    addDebugLog(`üìä Resultado do teste: ${newHeading?.toFixed(1)}¬∞`);
                }, 200);
            }
        };
        
        window.getMapInfo = function() {
            if (map) {
                const info = {
                    heading: map.getHeading(),
                    tilt: map.getTilt(),
                    zoom: map.getZoom(),
                    center: map.getCenter()?.toString(),
                    mapTypeId: map.getMapTypeId()
                };
                addDebugLog(`üìã Info do mapa: ${JSON.stringify(info)}`);
                return info;
            }
            return null;
        };

        // Initialize on page load
        window.addEventListener('load', function() {
            if (typeof google === 'undefined') {
                setTimeout(() => {
                    document.getElementById('mapLoading').innerHTML = `
                        <div style="color: white; text-align: center;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i><br>
                            Erro ao carregar mapa<br>
                            <button onclick="goBack()" style="margin-top: 1rem; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px;">Voltar</button>
                        </div>
                    `;
                }, 2000);
            }
        });
    </script>
</body>
</html>