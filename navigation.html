<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Navegação em Tempo Real</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            position: relative;
            /* overflow: hidden; */ /* Temporarily removed for testing */
            background: #1d1d1d;
        }

        /* Map Container will be oversized and rotated - 2x screen size to prevent empty areas */
        .map-container {
            position: fixed;
            top: -50vh;
            left: -50vw;
            width: 200vw;
            height: 200vh;
            z-index: 1;
            transition: transform 0.2s linear;
            overflow: hidden;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        /* The map div itself fills the oversized container */
        #map {
            width: 100%;
            height: 100%;
        }

        /* Loading Screen */
        .map-loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1d1d1d;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10000;
            color: white;
        }

        .map-loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #8a2be2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .map-loading-text {
            color: white;
            font-size: 1rem;
            text-align: center;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* UI Panels are fixed relative to the viewport */
        .top-instruction-panel, .bottom-info-panel, .floating-buttons {
            position: fixed;
            z-index: 200; /* Ensure UI is above the map container */
        }

        .top-instruction-panel {
            top: 0;
            left: 0;
            right: 0;
            background: #3d3d3d;
            color: white;
            padding: 8px 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .instruction-icon {
            font-size: 1.5rem;
            margin-bottom: 4px;
            color: #007bff;
        }

        .instruction-text {
            font-size: 0.9rem;
            font-weight: 600;
            line-height: 1.3;
        }

        .instruction-distance {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
            margin-top: 2px;
        }

        .bottom-info-panel {
            bottom: 0;
            left: 0;
            right: 0;
            background: #3d3d3d;
            padding: 12px;
            color: white;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.4);
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .route-info {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .route-stat {
            text-align: center;
            flex: 1;
        }

        .route-stat-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 4px;
        }

        .route-stat-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
        }
        
        .route-stat-value.speed {
            color: #007bff;
        }

        .floating-buttons {
            bottom: 100px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .fab {
            background-color: #3d3d3d;
            color: white;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .fab:hover {
            background-color: #4f4f4f;
            transform: scale(1.05);
        }
        
        .fab.active {
             background-color: #007bff;
        }

        .fab.stop {
            background-color: #dc3545;
        }
        .fab.stop:hover {
            background-color: #c82333;
        }

    </style>
</head>
<body>
    <!-- The map-container is now the oversized, rotating element -->
    <div class="map-container">
        <div id="map"></div>
    </div>

    <!-- UI Elements are outside the map-container -->
    <div class="map-loading" id="mapLoading">
        <div class="map-loading-spinner"></div>
        <div class="map-loading-text">
            Iniciando navegação...<br>
            <small>Aguardando sinal do GPS</small>
        </div>
    </div>

    <div class="top-instruction-panel" id="topInstructionPanel" style="display: none;">
        <div class="instruction-icon" id="instructionIcon"><i class="fas fa-arrow-up"></i></div>
        <div class="instruction-text" id="instructionText">Calculando rota...</div>
        <div class="instruction-distance" id="instructionDistance"></div>
    </div>

    <div class="bottom-info-panel" id="bottomInfoPanel" style="display: none;">
        <div class="route-info">
            <div class="route-stat">
                <div class="route-stat-label">Chegada</div>
                <div class="route-stat-value" id="arrivalTime">-</div>
            </div>
            <div class="route-stat">
                <div class="route-stat-label">Tempo Restante</div>
                <div class="route-stat-value" id="remainingTime">-</div>
            </div>
            <div class="route-stat">
                <div class="route-stat-label">Distância</div>
                <div class="route-stat-value" id="remainingDistance">-</div>
            </div>
            <div class="route-stat">
                <div class="route-stat-label">Velocidade</div>
                <div class="route-stat-value speed" id="currentSpeed">0 km/h</div>
            </div>
        </div>
    </div>

    <div class="floating-buttons">
        <button class="fab stop" onclick="stopNavigation()"><i class="fas fa-stop"></i></button>
        <button class="fab" id="simulationBtn" onclick="toggleSimulation()" title="Testar rotação com movimento simulado">
            <i class="fas fa-play"></i>
        </button>
        <button class="fab" id="compassBtn" onclick="toggleMapRotation()" title="Ativar rotação baseada no movimento">
            <i class="fas fa-location-arrow"></i>
        </button>
    </div>

    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA5CfnBBfbxBT0xLLpQxFNUCwA3DmVZilE&callback=initNavigation&libraries=geometry,places">
    </script>

    <script>
        let map;
        let directionsService;
        let directionsRenderer;
        let userLocation;
        let destinationLocation;
        let userMarker = null;
        let locationWatcherId = null;
        let currentRoute = null;
        let lastRecalculationTime = 0;
        let isMapRotationActive = false;
        let currentMapHeading = 0;
        let previousMapHeading = 0;
        let remainingRoutePolyline = null;
        let completedRoutePolyline = null;
        let lastPosition = null;
        let movementBearing = 0;
        let isMovementBasedRotation = true;

        function initNavigation() {
            const urlParams = new URLSearchParams(window.location.search);
            const destLat = parseFloat(urlParams.get('destLat'));
            const destLng = parseFloat(urlParams.get('destLng'));

            if (isNaN(destLat) || isNaN(destLng)) {
                alert('Destino inválido.');
                goBack();
                return;
            }
            destinationLocation = { lat: destLat, lng: destLng };

            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 18,
                center: { lat: 0, lng: 0 },
                mapTypeId: 'roadmap',
                disableDefaultUI: true,
                gestureHandling: 'greedy',
                styles: [ 
                    { elementType: "geometry", stylers: [{ color: "#242f3e" }] },
                    { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] },
                    { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] },
                    { featureType: "administrative.locality", elementType: "labels.text.fill", stylers: [{ color: "#d59563" }] },
                    { featureType: "poi", elementType: "labels.text.fill", stylers: [{ color: "#d59563" }] },
                    { featureType: "road", elementType: "geometry", stylers: [{ color: "#38414e" }] },
                    { featureType: "road", elementType: "geometry.stroke", stylers: [{ color: "#212a37" }] },
                    { featureType: "road", elementType: "labels.text.fill", stylers: [{ color: "#9ca5b3" }] },
                    { featureType: "road.highway", elementType: "geometry", stylers: [{ color: "#746855" }] },
                    { featureType: "road.highway", elementType: "geometry.stroke", stylers: [{ color: "#1f2835" }] },
                    { featureType: "transit", elementType: "geometry", stylers: [{ color: "#2f3948" }] },
                    { featureType: "water", elementType: "geometry", stylers: [{ color: "#17263c" }] },
                ]
            });

            directionsService = new google.maps.DirectionsService();
            // Don't use default directionsRenderer for route display
            // We'll manage polylines manually for progressive route completion

            startGpsTracking();
        }

        function startGpsTracking() {
            if (!navigator.geolocation) {
                alert('GPS não suportado neste navegador.');
                return;
            }
            locationWatcherId = navigator.geolocation.watchPosition(
                handleGpsUpdate,
                handleGpsError,
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        function handleGpsUpdate(position) {
            const newLocation = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            
            const speed = position.coords.speed ? (position.coords.speed * 3.6).toFixed(0) : 0;
            document.getElementById('currentSpeed').textContent = `${speed} km/h`;

            // Update movement bearing if we have a previous position
            if (lastPosition && isMovementBasedRotation) {
                updateMovementBearing(newLocation, lastPosition);
            }

            // Store current position as last position for next update
            lastPosition = userLocation ? { ...userLocation } : null;
            userLocation = newLocation;

            if (!userMarker) {
                document.getElementById('mapLoading').style.display = 'none';
                document.getElementById('topInstructionPanel').style.display = 'block';
                document.getElementById('bottomInfoPanel').style.display = 'block';
                createUserMarker();
                startNavigation();
                // Auto-activate movement-based rotation after a brief delay
                setTimeout(() => {
                    autoActivateMovementRotation();
                }, 1000);
            } else {
                userMarker.setPosition(userLocation);
            }

            map.setCenter(userLocation);

            // Apply rotation based on movement direction or device orientation
            if (isMapRotationActive) {
                const mapContainer = document.querySelector('.map-container');
                
                // Use movement bearing if available and moving, otherwise use device orientation
                let headingToUse = currentMapHeading;
                
                // Normalize heading and prevent 360° jumps
                const normalizedHeading = normalizeHeading(headingToUse, previousMapHeading);
                
                // Temporarily disable transition for large angle changes
                const angleDiff = Math.abs(normalizedHeading - previousMapHeading);
                if (angleDiff > 180) {
                    mapContainer.style.transition = 'none';
                    setTimeout(() => {
                        mapContainer.style.transition = 'transform 0.2s linear';
                    }, 50);
                }
                
                // Rotate map so that movement direction points up
                mapContainer.style.transform = `rotate(${360 - normalizedHeading}deg)`;
                
                // Update user marker to show movement direction
                const markerIcon = userMarker.getIcon();
                markerIcon.rotation = normalizedHeading;
                userMarker.setIcon(markerIcon);
                
                previousMapHeading = normalizedHeading;
            }
            
            if (currentRoute) {
                checkOffRoute();
                updateRemainingRouteInfo();
                updateProgressiveRoute();
            }
        }

        function handleGpsError(error) {
            console.error('GPS Error: ' + error.message);
        }

        function createUserMarker() {
            if (userMarker) userMarker.setMap(null);
            userMarker = new google.maps.Marker({
                position: userLocation,
                map: map,
                icon: {
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                    scale: 8,
                    fillColor: '#4285F4',
                    fillOpacity: 1.0,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2,
                    rotation: 0
                },
                zIndex: 1000
            });
        }

        function toggleMapRotation() {
            const compassBtn = document.getElementById('compassBtn');
            const mapContainer = document.querySelector('.map-container');

            if (isMapRotationActive) {
                // Turn off all rotation
                window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
                isMapRotationActive = false;
                isMovementBasedRotation = false;
                compassBtn.classList.remove('active');
                mapContainer.style.transform = 'rotate(0deg)';
                const markerIcon = userMarker.getIcon();
                markerIcon.rotation = 0;
                userMarker.setIcon(markerIcon);
                // Reset heading tracking
                currentMapHeading = 0;
                previousMapHeading = 0;
                movementBearing = 0;
                compassBtn.title = 'Ativar rotação baseada no movimento';
            } else if (!isMovementBasedRotation) {
                // Activate movement-based rotation
                isMapRotationActive = true;
                isMovementBasedRotation = true;
                compassBtn.classList.add('active');
                compassBtn.title = 'Alternar para bússola do dispositivo';
                console.log('Movement-based rotation activated');
            } else {
                // Switch to device orientation (compass) if available
                if (!window.isSecureContext) {
                    alert('REQUISITO DE SEGURANÇA: Para usar a bússola do dispositivo, esta página precisa ser acessada via HTTPS.');
                    return;
                }

                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                                isMovementBasedRotation = false;
                                compassBtn.title = 'Desativar rotação';
                                console.log('Device orientation rotation activated');
                            } else {
                                alert('Permissão para sensor de orientação foi negada.');
                            }
                        })
                        .catch(() => alert('Não foi possível ativar a bússola.'));
                } else {
                    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                    isMovementBasedRotation = false;
                    compassBtn.title = 'Desativar rotação';
                    console.log('Device orientation rotation activated');
                }
            }
        }

        function handleDeviceOrientation(event) {
            // Only use device orientation if not in movement-based rotation mode
            if (isMovementBasedRotation) return;
            
            let heading = 0;
            if (event.webkitCompassHeading) {
                heading = event.webkitCompassHeading;
            } else if (event.absolute && event.alpha !== null) {
                heading = 360 - event.alpha;
            }
            currentMapHeading = heading;
        }

        function startNavigation() {
            const request = {
                origin: userLocation,
                destination: destinationLocation,
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC
            };

            directionsService.route(request, (result, status) => {
                if (status === 'OK') {
                    currentRoute = result;
                    updateUiWithNewRoute();
                } else {
                    alert('Não foi possível calcular a rota: ' + status);
                    goBack();
                }
            });
        }

        function checkOffRoute() {
            const now = Date.now();
            if (now - lastRecalculationTime < 10000) return;

            const routePolyline = new google.maps.Polyline({ path: currentRoute.routes[0].overview_path });

            if (!google.maps.geometry.poly.isLocationOnEdge(userLocation, routePolyline, 1e-4)) {
                lastRecalculationTime = now;
                document.getElementById('instructionText').textContent = "Recalculando rota...";
                // Clear existing polylines before recalculating
                clearRoutePolylines();
                startNavigation();
            }
        }

        // Progressive route drawing functions
        function drawProgressiveRoute() {
            if (!currentRoute) return;

            // Clear existing polylines
            clearRoutePolylines();

            const routePath = currentRoute.routes[0].overview_path;
            
            // Create remaining route (full route initially)
            remainingRoutePolyline = new google.maps.Polyline({
                path: routePath,
                strokeColor: '#007bff',
                strokeWeight: 8,
                strokeOpacity: 0.8,
                zIndex: 100
            });
            remainingRoutePolyline.setMap(map);

            // Create completed route (empty initially)
            completedRoutePolyline = new google.maps.Polyline({
                path: [],
                strokeColor: '#28a745',
                strokeWeight: 6,
                strokeOpacity: 0.6,
                zIndex: 99
            });
            completedRoutePolyline.setMap(map);
        }

        function updateProgressiveRoute() {
            if (!currentRoute || !userLocation || !remainingRoutePolyline) return;

            const routePath = currentRoute.routes[0].overview_path;
            let closestPointIndex = 0;
            let minDistance = Number.MAX_VALUE;

            // Find closest point on route to user location
            for (let i = 0; i < routePath.length; i++) {
                const distance = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(userLocation.lat, userLocation.lng),
                    routePath[i]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPointIndex = i;
                }
            }

            // Only update if user has progressed significantly (more than 50 meters ahead)
            if (minDistance < 50 && closestPointIndex > 0) {
                // Split route into completed and remaining parts
                const completedPath = routePath.slice(0, closestPointIndex + 1);
                const remainingPath = routePath.slice(closestPointIndex);

                // Add user location to completed path for smooth transition
                completedPath.push(new google.maps.LatLng(userLocation.lat, userLocation.lng));

                // Update completed route (green)
                completedRoutePolyline.setPath(completedPath);

                // Update remaining route (purple)
                const remainingPathWithUser = [new google.maps.LatLng(userLocation.lat, userLocation.lng), ...remainingPath];
                remainingRoutePolyline.setPath(remainingPathWithUser);
            }
        }

        function clearRoutePolylines() {
            if (remainingRoutePolyline) {
                remainingRoutePolyline.setMap(null);
                remainingRoutePolyline = null;
            }
            if (completedRoutePolyline) {
                completedRoutePolyline.setMap(null);
                completedRoutePolyline = null;
            }
        }

        function updateUiWithNewRoute() {
            const leg = currentRoute.routes[0].legs[0];
            document.getElementById('remainingDistance').textContent = leg.distance.text;
            document.getElementById('remainingTime').textContent = leg.duration.text;
            
            const arrivalTime = new Date(Date.now() + leg.duration.value * 1000);
            document.getElementById('arrivalTime').textContent = arrivalTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });

            // Draw the full route initially
            drawProgressiveRoute();
            updateRemainingRouteInfo();
        }
        
        function updateRemainingRouteInfo() {
            if (!currentRoute) return;

            const leg = currentRoute.routes[0].legs[0];
            let nextStep = leg.steps[0];

            for (let i = 0; i < leg.steps.length - 1; i++) {
                const stepPolyline = new google.maps.Polyline({ path: leg.steps[i].path });
                if (google.maps.geometry.poly.isLocationOnEdge(userLocation, stepPolyline, 1e-4)) {
                    nextStep = leg.steps[i+1] || leg.steps[i];
                    break;
                }
            }
            
            document.getElementById('instructionText').innerHTML = nextStep.instructions;
            document.getElementById('instructionDistance').textContent = `em ${nextStep.distance.text}`;
            updateInstructionIcon(nextStep.maneuver);
        }

        function updateInstructionIcon(maneuver) {
            const iconEl = document.getElementById('instructionIcon');
            let iconClass = 'fas fa-arrow-up';
            switch (maneuver) {
                case 'turn-left': iconClass = 'fas fa-turn-left'; break;
                case 'turn-right': iconClass = 'fas fa-turn-right'; break;
                case 'turn-sharp-left': iconClass = 'fas fa-turn-down-left'; break;
                case 'turn-sharp-right': iconClass = 'fas fa-turn-down-right'; break;
                case 'uturn-left': iconClass = 'fas fa-u-turn-left'; break;
                case 'uturn-right': iconClass = 'fas fa-u-turn-right'; break;
                case 'roundabout-left': iconClass = 'fas fa-undo'; break;
                case 'roundabout-right': iconClass = 'fas fa-redo'; break;
                case 'merge': iconClass = 'fas fa-compress-arrows-alt'; break;
                case 'fork-left': iconClass = 'fas fa-code-branch'; break;
                case 'fork-right': iconClass = 'fas fa-code-branch fa-flip-horizontal'; break;
            }
            iconEl.innerHTML = `<i class="${iconClass}"></i>`;
        }

        // Auto-activate movement-based rotation
        function autoActivateMovementRotation() {
            if (isMapRotationActive) return; // Already active

            const compassBtn = document.getElementById('compassBtn');
            
            // Activate movement-based rotation by default
            isMapRotationActive = true;
            isMovementBasedRotation = true;
            compassBtn.classList.add('active');
            compassBtn.title = 'Alternar para bússola do dispositivo';
            console.log('Movement-based rotation activated automatically');
        }

        // Legacy compass function - kept for compatibility
        function autoActivateCompass() {
            // Now calls the movement-based rotation instead
            autoActivateMovementRotation();
        }

        function activateCompass(compassBtn) {
            // This function is now used only for device orientation
            window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            isMapRotationActive = true;
            isMovementBasedRotation = false;
            compassBtn.classList.add('active');
            compassBtn.title = 'Desativar rotação';
            console.log('Device compass navigation activated');
        }

        // Calculate bearing between two GPS points
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            
            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - 
                     Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360; // Normalize to 0-360
        }

        // Calculate distance between two GPS points (in meters)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Update movement bearing based on GPS positions
        function updateMovementBearing(currentPos, previousPos) {
            if (!previousPos || !currentPos) return;
            
            // Calculate distance to ensure we have significant movement
            const distance = calculateDistance(
                previousPos.lat, previousPos.lng,
                currentPos.lat, currentPos.lng
            );
            
            // Only update bearing if movement is significant (> 5 meters)
            if (distance > 5) {
                const newBearing = calculateBearing(
                    previousPos.lat, previousPos.lng,
                    currentPos.lat, currentPos.lng
                );
                
                // Smooth bearing changes to avoid jittery rotation
                if (Math.abs(newBearing - movementBearing) < 180) {
                    movementBearing = movementBearing * 0.7 + newBearing * 0.3; // Smooth transition
                } else {
                    // Handle 360° wrap-around case
                    let adjustedNew = newBearing;
                    let adjustedCurrent = movementBearing;
                    
                    if (newBearing < 90 && movementBearing > 270) {
                        adjustedNew += 360;
                    } else if (movementBearing < 90 && newBearing > 270) {
                        adjustedCurrent += 360;
                    }
                    
                    const smoothed = adjustedCurrent * 0.7 + adjustedNew * 0.3;
                    movementBearing = smoothed % 360;
                }
                
                currentMapHeading = movementBearing;
            }
        }

        // Normalize heading to prevent 360° jumps
        function normalizeHeading(newHeading, previousHeading) {
            // Ensure values are between 0 and 360
            newHeading = newHeading % 360;
            if (newHeading < 0) newHeading += 360;
            
            previousHeading = previousHeading % 360;
            if (previousHeading < 0) previousHeading += 360;
            
            // Calculate the difference
            let diff = newHeading - previousHeading;
            
            // Normalize the difference to be between -180 and 180
            while (diff > 180) diff -= 360;
            while (diff < -180) diff += 360;
            
            // Return the smoothed heading
            return previousHeading + diff;
        }

        // Movement simulation for testing (only for development)
        let simulationInterval = null;
        let simulationStep = 0;
        
        function startMovementSimulation() {
            if (simulationInterval) return;
            
            console.log('Starting movement simulation for testing...');
            const startLat = userLocation ? userLocation.lat : -23.55052;
            const startLng = userLocation ? userLocation.lng : -46.633308;
            
            simulationInterval = setInterval(() => {
                // Simulate movement in a spiral pattern
                const radius = 0.0001; // Very small radius
                const angle = simulationStep * 0.1;
                const newLat = startLat + Math.cos(angle) * radius * simulationStep * 0.01;
                const newLng = startLng + Math.sin(angle) * radius * simulationStep * 0.01;
                
                const simulatedPosition = {
                    coords: {
                        latitude: newLat,
                        longitude: newLng,
                        speed: 10 // 10 m/s = 36 km/h
                    }
                };
                
                handleGpsUpdate(simulatedPosition);
                simulationStep++;
                
                // Stop after 100 steps
                if (simulationStep > 100) {
                    stopSimulation();
                }
            }, 1000);
            
            // Update button appearance
            const simulationBtn = document.getElementById('simulationBtn');
            simulationBtn.classList.add('active');
            simulationBtn.innerHTML = '<i class="fas fa-pause"></i>';
            simulationBtn.title = 'Parar simulação';
        }
        
        function stopSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                simulationStep = 0;
                console.log('Movement simulation stopped');
            }
            
            // Update button appearance
            const simulationBtn = document.getElementById('simulationBtn');
            simulationBtn.classList.remove('active');
            simulationBtn.innerHTML = '<i class="fas fa-play"></i>';
            simulationBtn.title = 'Testar rotação com movimento simulado';
        }
        
        function toggleSimulation() {
            if (simulationInterval) {
                stopSimulation();
            } else {
                startMovementSimulation();
            }
        }
        
        // Add keyboard shortcut for testing (Ctrl+T)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 't') {
                event.preventDefault();
                startMovementSimulation();
            }
        });

        // Navigation controls
        function goBack() {
            window.history.back();
        }

        function stopNavigation() {
            if (confirm('Deseja parar a navegação?')) {
                if (locationWatcherId) navigator.geolocation.clearWatch(locationWatcherId);
                window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
                stopSimulation();
                clearRoutePolylines();
                goBack();
            }
        }
        

        window.gm_authFailure = function() {
            console.error('❌ Google Maps API authentication failed');
            document.getElementById('mapLoading').innerHTML = `
                <div style="color: white; text-align: center;">
                    <i class="fas fa-key" style="font-size: 2rem; margin-bottom: 1rem; color: #dc3545;"></i><br>
                    Erro de autenticação do mapa<br>
                    <small>Chave da API inválida ou expirada</small><br>
                    <button onclick="goBack()" style="margin-top: 1rem; padding: 10px 20px; background: #8a2be2; color: white; border: none; border-radius: 5px;">Voltar</button>
                </div>
            `;
        };
    </script>
</body>
</html>